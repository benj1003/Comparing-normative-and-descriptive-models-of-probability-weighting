# Master-thesis: Normative accounts of Probability Weighting in Decision Science

This reposetory contains all code and code needed to replicate the work done in the final project done to fulfill the requirements to obtain a masters degree in Mathematical Modelling and Computation from the Technical University of Denmark (DTU) by stud. polyt Benjamin Skjold Frederiksen. 

## Data
The reposetory contains the data needed to replicate all findings. Due to size limitations no output files are uploaded, but can be requested. I though emphasize that all code used to generate the pseudo-random data is uploaded and one can therefore produce the output files and thus replicate all findings. 

However, it also contains the code that was used to generate the pseudo-random data, such that the full process can be replicated. 

## Platform/Environment
The raw data (the underlying gambles) is in .csv format. A python script (Python 3.7.1) reads this and generate the trials for each gamble (converting from decision from description to decisions from experience).

The analyses have been performed with, or called from Matlab. The Hierarchical Bayesian modelling has been run with JAGS (via matjags, which allows running JAGS via matlab code) - see https://sourceforge.net/projects/mcmc-jags/.

## Folder summary

- Figures: Contain all figures used within the project (both final paper and various presentations)
- Generating gambles: Contains the .cvs file with all underlying gambles, as well as the Python script used to convert each gambles into a series of trials
- Presentations: Contain slides used in presentations regarding the project
- Recovery: Contain all files used to run simulations (including simulation choices, model recovery and parameter recovery)
  - analysis: contain Python scripts used to run parameter recovery and model recovery (also contain seperate script for functions used).
  - data: Folder in which data generated by Python scrpit in "Generating gambles" folder is placed.
  - JAGS: contain the "JAGS" script using JAGS code that are called by the matjags script.
  - matjags: Contain matjags script that is the means by which matlab runs JAGS.
  - samples_stats: Folder in which all outputs from JAGS, including all relevant statistics and samples for further analysis, is placed. 
  
## Setting up JAGS
JAGS is run via matjags - see https://github.com/msteyvers/matjags for detailed description of instalation.

## Detailed Setup Instructions - running JAGS
Runnning a model starts with setting up the script runHLM.m, which contains different specifications for running a JAGS model, pertaining to the following key variables: 
- mode: 1=simulate CPT choices,2=simulate LML choices, 3=model recovery for CPT choices, 4=model recovery for LML choices, 5=parameter revovery CPT, 6=parameter 'recovery' LML
- whichJAGS: which copy of matjags to run on. this allows parallel jobs to run as long as they use different matjags
- whichQuals: sets the order of qualities to run
- nGambles: number of gambles to run over (must be less than or equan to number of gambles generated by Trial_generation.py)
- nAgents: number of synthetic agents (must be less than or equan to number of agents generated by Trial_generation.py)

To call a given runHLM you need to run the job runHLM_job.sh in the "Recovery" directory. runHLM.m calls setHLM.m, which contains preset information about what the different quality levels mean in terms of burn-in, number of samples etc.

setHLM setHLM then calls computeHLM which is the main script for computing the hieararchical bayesian models. This script processes the data, and principally calls matjags to run the model. This is done by calling the different versions of the "JAGS_..." scripts using JAGS code, to be found in the folder "Recovery/JAGS"

computeHLM is a general script for running several types of hierarchical bayesian model via JAGS. It can run hiearchical latent mixture models in which different utility models can be compared via inference on the model indicator variables, and it can run without latent mixtures of models for instance in order to estimate parameters of a given utility model.


